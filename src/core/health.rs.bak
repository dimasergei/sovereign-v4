//! Health Monitor - Detects and recovers from data gaps
//! 
//! Bar-based monitoring for Alpaca 1-minute bars.
//! Expects bars every 60 seconds, alerts if no bar for 90+ seconds.

use std::time::{Duration, Instant};

pub struct HealthMonitor {
    last_bar: Instant,
    bar_timeout: Duration,
    gap_count: u32,
    total_bars: u64,
    is_market_open: bool,
}

impl HealthMonitor {
    pub fn new() -> Self {
        Self {
            last_bar: Instant::now(),
            bar_timeout: Duration::from_secs(90),  // 60s bar + 30s buffer
            gap_count: 0,
            total_bars: 0,
            is_market_open: false,
        }
    }

    /// Call this when a bar is received
    pub fn record_bar(&mut self) {
        self.last_bar = Instant::now();
        self.total_bars += 1;
        // Reset gap counter on successful bar
        if self.gap_count > 0 {
            self.gap_count = 0;
        }
    }

    /// Update market status (don't alert during closed hours)
    pub fn set_market_open(&mut self, is_open: bool) {
        self.is_market_open = is_open;
        // Reset timers when market opens
        if is_open {
            self.last_bar = Instant::now();
        }
    }

    /// Check health status - call this periodically (e.g., every 10s)
    pub fn check(&mut self) -> HealthStatus {
        // Don't count gaps when market is closed
        if !self.is_market_open {
            return HealthStatus::MarketClosed;
        }

        let bar_age = self.last_bar.elapsed();

        if bar_age > self.bar_timeout {
            self.gap_count += 1;
            return HealthStatus::StaleData {
                seconds: bar_age.as_secs(),
                gaps: self.gap_count,
            };
        }

        HealthStatus::Healthy { gaps: self.gap_count }
    }

    /// Should we send a Telegram alert?
    /// Alert at 5 minutes (300s) without bars, then every 5 minutes
    pub fn should_alert(&self) -> bool {
        if !self.is_market_open {
            return false;
        }
        let secs = self.last_bar.elapsed().as_secs();
        // Alert at 300s, 600s, 900s, etc.
        secs >= 300 && secs % 300 < 10
    }

    /// How many consecutive gaps detected
    pub fn gap_count(&self) -> u32 {
        self.gap_count
    }

    /// Total bars received this session
    pub fn total_bars(&self) -> u64 {
        self.total_bars
    }

    /// Seconds since last bar
    pub fn bar_age_secs(&self) -> u64 {
        self.last_bar.elapsed().as_secs()
    }

    /// Is data currently stale?
    pub fn is_stale(&self) -> bool {
        self.is_market_open && self.last_bar.elapsed() > self.bar_timeout
    }
}

impl Default for HealthMonitor {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub enum HealthStatus {
    Healthy { gaps: u32 },
    StaleData { seconds: u64, gaps: u32 },
    MarketClosed,
}

impl HealthStatus {
    pub fn is_healthy(&self) -> bool {
        matches!(self, HealthStatus::Healthy { .. } | HealthStatus::MarketClosed)
    }
}
