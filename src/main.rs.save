//! Sovereign v4.0 "Perpetual" - Institutional Autonomous Trading System

use anyhow::Result;
use tracing::{info, warn, Level};
use tracing_subscriber::FmtSubscriber;
use tokio::sync::mpsc;
use rust_decimal::Decimal;
use rust_decimal_macros::dec;
use std::str::FromStr;
use chrono::{Utc, Weekday, Timelike, Datelike};

mod core;
mod broker;
mod data;
mod comms;
mod config;

use crate::core::types::Candle;
use crate::core::coordinator::Coordinator;
use crate::core::strategy::SignalDirection;
use crate::core::health::{HealthMonitor, HealthStatus};
use crate::data::alpaca_stream::{self, AlpacaMessage};
use crate::data::database::TradeDb;
use crate::broker::alpaca::AlpacaBroker;
use crate::comms::telegram;
use crate::config::Config;

const SEP: &str = "===========================================================";

/// Check if US stock market is open
fn is_market_open() -> bool {
    let now = Utc::now();
    let weekday = now.weekday();
    
    // Market closed on weekends
    if weekday == Weekday::Sat || weekday == Weekday::Sun {
        return false;
    }
    
    // Market hours: 9:30 AM - 4:00 PM ET (14:30 - 21:00 UTC)
    let hour = now.hour();
    let minute = now.minute();
    let time_minutes = hour * 60 + minute;
    
    // 14:30 UTC = 870 minutes, 21:00 UTC = 1260 minutes
    time_minutes >= 870 && time_minutes < 1260
}

/// Smart alerting - only alert on significant events
struct AlertManager {
    last_gap_alert: std::time::Instant,
    gap_alert_interval: std::time::Duration,
    consecutive_gaps: u32,
}

impl AlertManager {
    fn new() -> Self {
        Self {
            last_gap_alert: std::time::Instant::now(),
            gap_alert_interval: std::time::Duration::from_secs(300), // 5 min between alerts
            consecutive_gaps: 0,
        }
    }
    
    fn should_alert_gap(&mut self, gap_count: u32) -> bool {
        self.consecutive_gaps = gap_count;
        
        // Only alert every 5 minutes, and only if market should be open
        if self.last_gap_alert.elapsed() >= self.gap_alert_interval && is_market_open() {
            self.last_gap_alert = std::time::Instant::now();
            true
        } else {
            false
        }
    }
    
    fn reset(&mut self) {
        self.consecutive_gaps = 0;
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let cfg = Config::load("config.toml").unwrap_or_else(|e| {
        eprintln!("Failed to load config.toml: {}. Exiting.", e);
        std::process::exit(1);
    });
    
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .with_target(false)
        .with_thread_ids(true)
        .finish();
    
    tracing::subscriber::set_global_default(subscriber)?;
    
    info!("{}", SEP);
    info!("  {} - Perpetual Autonomous Trading System", cfg.system.name);
    info!("{}", SEP);
    
    // Require Alpaca config
    let alpaca_cfg = cfg.alpaca.clone().expect("Alpaca config required");
    
    let db = TradeDb::new("sovereign_trades.db")?;
    
    if let Ok((total, wins, _losses, pnl)) = db.get_total_stats() {
        if total > 0 {
            let win_rate = (wins as f64 / total as f64) * 100.0;
            info!("Historical: {} trades | {:.1}% win rate | ${:.2} P&L", total, win_rate, pnl);
        }
    }
    
    let risk_config = cfg.risk.to_guardian_config();
    let mut coordinator = Coordinator::with_config(cfg.risk.max_positions, risk_config);
    
    let symbols: Vec<String> = cfg.symbols.iter().map(|s| s.name.clone()).collect();
    
    for sym in &cfg.symbols {
        coordinator.add_agent(&sym.name, sym.tick_size_decimal(), sym.is_forex);
        info!("Agent: {} (tick={}, forex={})", sym.name, sym.tick_size, sym.is_forex);
    }
    
    info!("Agents: {} symbols loaded", coordinator.agent_count());
    
    // Initialize Alpaca broker
    let broker = AlpacaBroker::new(
        alpaca_cfg.api_key.clone(),
        alpaca_cfg.secret_key.clone(),
        cfg.broker.paper,
    );
    
    // Initialize state variables
    let mut current_balance = dec!(100000);
    let mut current_equity = dec!(100000);
    
    // Get initial account info and UPDATE balance
    match broker.get_account().await {
        Ok(account) => {
            current_balance = Decimal::from_str(&account.equity).unwrap_or(dec!(100000));
            current_equity = current_balance;
            info!("Alpaca Account: ${} equity, ${} cash, ${} buying power", 
                account.equity, account.cash, account.buying_power);
        }
        Err(e) => {
            warn!("Failed to get account info: {}", e);
        }
    }
    
    // POSITION RECOVERY: Query and register existing positions
    match broker.get_positions().await {
        Ok(positions) => {
            if !positions.is_empty() {
                info!("{}", SEP);
                info!("RECOVERING {} EXISTING POSITION(S):", positions.len());
                for pos in &positions {
                    info!("  {} {} shares @ ${} | P&L: ${}", 
                        pos.symbol, pos.qty, pos.avg_entry_price, pos.unrealized_pl);
                    // Register with coordinator so it knows we have an open position
                    let side = if pos.side == "long" { SignalDirection::Buy } else { SignalDirection::Sell };
                    coordinator.position_opened(&pos.symbol, 0, side);
                }
                info!("{}", SEP);
            } else {
                info!("No existing positions to recover");
            }
        }
        Err(e) => {
            warn!("Failed to get positions: {}", e);
        }
    }
    
    if cfg.telegram.enabled {
        telegram::send_startup().await;
    }
    
    let (tx, mut rx) = mpsc::channel::<AlpacaMessage>(100);
    
    // Health monitor
    let mut health = HealthMonitor::new();
    let mut last_health_check = std::time::Instant::now();
    
    // Smart alert manager (reduces spam)
    let mut alert_manager = AlertManager::new();
    
    let mut tick_count = 0u64;
    let mut candle_count = 0u64;
    let mut total_pnl = Decimal::ZERO;
    let mut trade_count = 0u32;
    
    let max_positions = cfg.risk.max_positions;
    let min_conviction = cfg.strategy.min_conviction;
    let telegram_enabled = cfg.telegram.enabled;
    
    // Spawn Alpaca WebSocket connection
    let api_key = alpaca_cfg.api_key.clone();
    let api_secret = alpaca_cfg.secret_key.clone();
    let symbols_clone = symbols.clone();
    
    tokio::spawn(async move {
        loop {
            info!("Connecting to Alpaca stream...");
            if let Err(e) = alpaca_stream::connect(&api_key, &api_secret, &symbols_clone, tx.clone()).await {
                warn!("Alpaca stream error: {}. Reconnecting in 5s...", e);
            }
            tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
        }
    });
    
    info!("Strategy: min_conviction={}, risk_reward=1:{}", min_conviction, cfg.strategy.risk_reward_ratio);
    info!("Guardian: {}", coordinator.guardian_status());
    info!("Broker: Alpaca (paper={})", cfg.broker.paper);
    info!("Health: Monitoring enabled (90s bar timeout)");
    info!("Market Status: {}", if is_market_open() { "OPEN" } else { "CLOSED" });
    info!("Waiting for market data...");
    
    loop {
        // Check health every 10 seconds
        if last_health_check.elapsed().as_secs() >= 10 {
            last_health_check = std::time::Instant::now();
            
health.set_market_open(is_market_open());

match health.check() {
    HealthStatus::Healthy { gaps: _ } => {
        alert_manager.reset();
    }
    HealthStatus::MarketClosed => {
        // No warnings when market closed
    }
    HealthStatus::StaleData { seconds, gaps } => {            match health.check() {
                HealthStatus::Healthy => {
                    alert_manager.reset();
                }
                HealthStatus::StaleData { seconds, gaps } => {
                    // Only warn if market should be open
                    if is_market_open() {
                        warn!("HEALTH: No bars for {}s (gap #{})", seconds, gaps);
                        
                        // Smart alerting: only send telegram every 5 min
                        if alert_manager.should_alert_gap(gaps) && telegram_enabled {
                            let _ = telegram::send(&format!(
                                "⚠️ Data gap: {}s without ticks (gap #{}) - Market: {}",
                                seconds, gaps, if is_market_open() { "OPEN" } else { "CLOSED" }
                            )).await;
                        }
                    }
                }
                HealthStatus::MissingCandles { seconds } => {
                    if is_market_open() {
                        warn!("HEALTH: No candles for {}s", seconds);
                    }
                }
            }
        }
        
        // Non-blocking receive with timeout
        match tokio::time::timeout(
            tokio::time::Duration::from_millis(100),
            rx.recv()
        ).await {
            Ok(Some(msg)) => {
                match msg {
                    AlpacaMessage::Connected => {
                        info!("Connected to Alpaca stream!");
                    }
                    AlpacaMessage::Tick(tick) => {
                        tick_count += 1;
                        // ticks dont reset health
                        alert_manager.reset();
                        coordinator.update_tick(&tick.symbol, tick.bid, tick.ask);
                        
                        if tick_count % 100 == 0 {
                            info!("Tick #{}: {} bid={} ask={}", tick_count, tick.symbol, tick.bid, tick.ask);
                        }
                    }
                    AlpacaMessage::Bar(bar) => {
                        candle_count += 1;
                        health.record_bar();
                        alert_manager.reset();
                        coordinator.check_daily_reset(current_balance);
                        
                        let c = Candle::new(
                            chrono::Utc::now(),
                            bar.open,
                            bar.high,
                            bar.low,
                            bar.close,
                            bar.volume.into(),
                        );
                        
                        coordinator.update_candle(&bar.symbol, &c);
                        
                        if let Some(obs) = coordinator.get_observation(&bar.symbol) {
                            info!("{}", SEP);
                            info!("BAR #{}: {} | O={} H={} L={} C={}", 
                                candle_count, bar.symbol, bar.open, bar.high, bar.low, bar.close);
                            info!("Trend: {} | Momentum: {} | Volume: {:?}", 
                                obs.trend, obs.momentum, obs.volume_state);
                            info!("Positions: {}/{} | Health: OK (gaps: {})", 
                                coordinator.active_position_count(), max_positions, health.gap_count());
                        }
                        
                        // Only generate signals if market is open
                        if !is_market_open() {
                            info!("Signal: HOLD | Market closed");
                            info!("{}", SEP);
                            continue;
                        }
                        
                        let signals = coordinator.collect_signals(current_balance, current_equity);
                        
                        if signals.is_empty() {
                            info!("Signal: HOLD | No opportunities");
                        } else {
                            for signal in &signals {
                                info!("Signal #{}: {} {:?} | Conviction: {}%", 
                                    signal.rank, signal.symbol, signal.direction, signal.conviction);
                            }
                            
                            if let Some(best) = signals.first() {
                                info!("{}", SEP);
                                info!("EXECUTING: {} {:?}", best.symbol, best.direction);
                                info!("  Entry: {} | SL: {} | TP: {}", best.price, best.stop_loss, best.take_profit);
                                info!("  Conviction: {}%", best.conviction);
                                info!("{}", SEP);
                                
                                let dir_str = format!("{:?}", best.direction);
                                if telegram_enabled {
                                    telegram::send_signal(
                                        &dir_str,
                                        &best.price.to_string(),
                                        &best.stop_loss.to_string(),
                                        &best.take_profit.to_string(),
                                        best.conviction,
                                    ).await;
                                }
                                
                                // Calculate quantity (shares for stocks)
                                let qty = dec!(1); // Start with 1 share for testing
                                
                                match best.direction {
                                    SignalDirection::Buy => {
                                        match broker.buy(&best.symbol, qty, Some(best.stop_loss), Some(best.take_profit)).await {
                                            Ok(order) => {
                                                info!("BUY ORDER: {} status={}", order.id, order.status);
                                                trade_count += 1;
                                                coordinator.position_opened(&best.symbol, 0, SignalDirection::Buy);
                                            }
                                            Err(e) => warn!("Buy failed: {}", e),
                                        }
                                    }
                                    SignalDirection::Sell => {
                                        match broker.sell(&best.symbol, qty, Some(best.stop_loss), Some(best.take_profit)).await {
                                            Ok(order) => {
                                                info!("SELL ORDER: {} status={}", order.id, order.status);
                                                trade_count += 1;
                                                coordinator.position_opened(&best.symbol, 0, SignalDirection::Sell);
                                            }
                                            Err(e) => warn!("Sell failed: {}", e),
                                        }
                                    }
                                    SignalDirection::Hold => {}
                                }
                            }
                        }
                        
                        info!("{}", SEP);
                    }
                    AlpacaMessage::Error(err) => {
                        warn!("Alpaca error: {}", err);
                    }
                }
            }
            Ok(None) => {
                warn!("Channel closed. Exiting.");
                break;
            }
            Err(_) => {
                // Timeout - no message, continue loop for health checks
            }
        }
    }
    
    Ok(())
}
